\documentclass{article}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage{subcaption}
\usepackage[linewidth=1pt]{mdframed}
\usepackage[colorlinks]{hyperref}

\usepackage{verbatim}

\usepackage{algorithm}
\usepackage{algpseudocode}

\hypersetup{citecolor=DeepPink4}
\hypersetup{linkcolor=DarkRed}
\hypersetup{urlcolor=Blue}

\usepackage{cleveref}

\setlength{\parindent}{1em}
\setlength{\parskip}{1em}
\renewcommand{\baselinestretch}{1.0}

\begin{document}

\begin{titlepage}
	\centering
	{\scshape\LARGE Assignment 4\par}
	\vspace{1cm}
	{\scshape\Large Algorithms \& Complexity (CIS 522-01)\par}
	\vspace{1.5cm}
	{\Large\itshape Javier Arechalde\par}
	\vfill
	{\large \today\par}
\end{titlepage}

\section*{Part A: Read the solved exercises and Practice}

\subsection*{Solved excercise \#1 in Chapter 5}

In this problem, we have an array with $n$ entries, and inside this array, we have a peak entry $p$ in a position $j$ of the array, so that the values in the array prior to $j$ go in increasing order, and after the peak value, they go in decreasing order.

Our goal is to find that peak entry $p$ without having to read the entire array, and only by reading as few values as possible. 

\subsubsection*{Algorithm Pseudocode}

\begin{algorithm}[H]
\caption{Finding maximum pseudocode}
\begin{algorithmic}[1]
\Function{Findmaximum}{$pos_{start},pos_{end},array$}
 \State $n = (pos_{start}+pos_{end})/(2)$
 \If{$array(\frac{n}{2}-1)<array(\frac{n}{2})<array(\frac{n}{2}+1)$}
  \State We have a \textbf{positive slope}, so we havent reached the maximum yet
  \State \Call{Findmaximum}{$(pos_{start}+pos_{end})/2, pos_{end}, array$}
 \ElsIf{$array(\frac{n}{2}-1)>array(\frac{n}{2})>array(\frac{n}{2}+1)$}
  \State We have a \textbf{negative slope}, we already passed the maximum
  \State \Call{Findmaximum}{$pos_{start},(pos_{start}+pos_{end})/2$}
 \ElsIf{$array(\frac{n}{2}-1)>array(n/2)<array(\frac{n}{2}+1)$}
  \State We have found the \textbf{maximum point}
  \State \Return value(n/2)
 \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection*{Solution for problem instance of size $10$}

In this case, we will run our algorithm, when we have an instance of size $10$.

In this problem's scope, we will have an set of increasing numbers that grow until a maximum, followed by another set of numbers that go in decreasing order.

This will be our problem's working set:

$$S = [1,2,4,12,14,21,6,4,3,1]$$

If we start running the algorithm, we will check the number in the $5^{th}$ position.

In this case we will have that $S[4]<S[5]<S[6]$, which means that we are in a positive slope, and we still haven't reached the maximum. Then we will call the function again, so in the next iteration of our algorithm, we will work with this set.

$$S' = [14,21,6,4,3,1]$$

Now we will check the $3^{rd}$ position. In this case we have that $S[2]>S[3]>S[4]$, which means that we are in a negative slope, so we already passed the maximum. Thus, we will call the function again, and in the next iteration of our algorithm we will work with this set.

$$S'' = [14,21,6]$$

Now we will check the middle position, in this case the $2^{nd}$ position. We get the result that $S[1]<S[2]>S[3]$, which means that the number we are checking is indeed the maximum. Now we will return that value, and stop running our algorithm.

$$max = 21$$

\subsubsection*{Time Complexity}

In this problem, with each one of the recursive calls, we reduce the problem to one of at most half the size of the initial problem. Then:

$$T(n)\leq T(n/2) + c$$

when $n>2$, and

$$T(2)\leq c.$$

Then, the running time of our algorithm will be $O(\log n)$.

\subsection*{Solved exercise \#2 in Chapter 5}

In this problem, we have an investment company that looks at $n$ consecutive days of a given stock. For each of these days, the stock has a price $p(i)$ per share for the stock on that day. We assume that the stock prize was fixed on that day.

The goal is to find, without having to check each possible combination of days, which will take $O(n^2)$, in which day they should have bought the shares, and in which day they must have sold them to make as much money as possible.

\subsubsection*{Algorithm Pseudocode}

\begin{algorithm}[H]
\caption{Stocks Divide-and-Conquer pseudocode}
\begin{algorithmic}[1]
\Function{Max}{list}
 \State $max$
 \For{element in list}
  \If{$element>max \quad \textbf{or} \quad max == NA$}
   \State max = element
  \Else{}
   \State \textbf{continue}
  \EndIf
 \EndFor
 \State \Return max
\EndFunction
\State
\Function{Min}{list}
 \State $min$
 \For{element in list}
  \If{$element<min \quad \textbf{or} \quad min == NA$}
   \State min = element
  \Else{}
   \State \textbf{continue}
  \EndIf
 \EndFor
 \State \Return min
\EndFunction
\State
\Function{FindOpt}{$array$}
\If{$len(array)>2$}
 \State $Larray = array[0:len(array)/2]$
 \State $Rarray = array[len(array)/2:len(array)]$
 \State
 \State LSide = \Call{FindOpt}{$Larray$}
 \State RSide = \Call{FindOpt}{$Rarray$}
 \State
 \State LOpt = LSide[1] - LSide[0]
 \State ROpt = RSide[1] - RSide[0]
 \State MOpt = \Call{Max}{RSide} - \Call{Min}{LSide}
 \State
 \State Marray = [min(LSide),max(RSide)]
 \State
 \State maxvalue = \Call{Max}{LOpt,ROpt,MOpt}

 \If {$maxvalue == LOpt$}
  \State \Return LSide
 \ElsIf{$maxvalue == ROpt$}
  \State \Return RSide
 \ElsIf{$maxvalue == MOpt$}
  \State \Return Marray
 \EndIf
 \State
\ElsIf{$len(array) <= 2$}
 \State \Return array
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection*{Solution for problem instance of size $10$}

Now we will compute a solution using our algorithm for a problem instance of size 10.

This will be the set we are going to work with.

$$S = [7,4,3,2,5,7,10,20,14,7]$$

First, as the array is longer than 2, we will divide it into two sets recursively until we have arrays of length smaller or equal to 2.

$$[7,4,3,2,5] \quad [7,10,20,14,7]$$

$$[7,4] \quad [3,2,5] \quad [7,10] \quad [20,14,7]$$

$$[7,4] \quad [3,2] \quad [5] \quad [7,10] \quad [20,14] \quad [7]$$

Now we are going to compare set by set, if the optimal solution between one set, compare it with the other set, and compare it also with the maximum of the "right" set and the minimum of the "left" set, and see which one gives us a better solution.

$$[7,4] \quad \& \quad [3,2]$$

$$OptL = 4-7 = -3 \quad OptR = 2-3 = -1 \quad OptM = 3-4 = -1$$

$$[5] \quad \& \quad [7,10]$$

$$OptM = 10-5 = 5 \quad OptR = 3$$

$$[20,14] \quad  \& \quad [7]$$

$$OptL = -6 \quad OptM = 7-14 = -7$$

We return $[3,2] \quad [5,10] \quad [20,14]$.

Now we have:

$$[3,2] \quad [5,10] \quad [20,14]$$

Lets start comparing.

$$[3,2] \quad \& \quad [5,10]$$

$$OptL = -1 \quad OptR = 5 \quad OptM = 10 - 2 = 8$$

We return $[2,10]$.

Now we have:

$$[2,10] \quad \& \quad [20,14]$$

$$OptL = 8 \quad OptR = -6 \quad OptM = 18$$

We finally return $[2,20]$, and that will be our final result.

\subsubsection*{Time Complexity}

As we said, in this problem, we will have to recursively subdivide our array, and take the best possible solution out of this three possible solutions:

\begin{itemize}
 \item The optimal solution on $S$
 \item The optimal solution on $S'$
 \item the optimal solution of $p(j)-p(i)$, over $i \in S$ and $j \in S'$.
\end{itemize}

The first two items are computed, in time $T(n/2)$ by recursion, and the third item is computed by finding the maximum in $S'$ and the minimum in $S$, which can be done in $O(n)$ time. Then our running time $T(n)$ satisfies

$$T(n) \leq 2T(\frac{n}{2})+O(n)$$,

Then the time complexity of our implementation will be $O(n\log n)$.


\section*{Part B: Problem Solving}

\subsection*{Significant inversion}

\subsubsection*{Problem Model}

In this problem, we are given a sequence of $n$ numbers $a_1,...,a_n$, which we will we assume that are all distinct, and we define inversion to be a pair $i<j$ such that $a_i>a_j$. We call a pair \textit{significant inversion} if $i<j$ and $a_i<2a_j$.

Our goal is to count the number of \textit{significant inversions} between two orderings, using an algorithm that has $O(n \log n)$ time complexity.

\subsubsection*{Pseudocode}

\begin{algorithm}[H]
\caption{Significant inversion pseudocode}
\begin{algorithmic}[1]
\Function{CountInversions}{array}
 \If{$length(array)>2$}
  \State Divide the array in two
  \State $array_left = array[0:mid]$
  \State $array_{right} = array[mid:end]$
  \State Now we recursively divide the array
  \State $array_{left} = \Call{CountInversions}{array_{left}}$
  \State $array_{right} = \Call{CountInversions}{array_{right}}$
  \While{We havent sorted $array_left$ and $array_{right}$}
   \If{We added all the elements in $array_left$}
    \State Take one element from $array_{left}$ and another one from $array_right$
    \State $value_left$ and $value_{right}$
    \State $array_{sorted} = array_{sorted} + array_{right}$
   \EndIf
   \If{We added all the elements in $array_right$}
    \State $array_{sorted} = array_{sorted} + array_{left}$
   \EndIf
   
   \If{Element in $value_{left}<value_{right}$}
    \State Add that element to $array_{sorted}$
   \Else
    \If{Element in $value_{left}>2*value_{right}$}
     \State That means that all the elements remaining in the $array_{left}$ are also greater
     \State thant the element being checked into the right array, so we add as many numbers come
     \State after the value in the right array to the count of significant inversions.
    \EndIf
   \EndIf
  \EndWhile
  \State \Return $array_{sorted}$
 \EndIf
 \If{$length(array) == 1$}
  \State \Return array
 \ElsIf
  \If{$array[0]<array[1]$}
   \State \Return $array[0],array[1]$
  \Else
   \If{$array[0]>2*array[0]$}
    \State $N_{inv}++$
   \EndIf
   \State \Return $array[1],array[0]$
  \EndIf
 \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection*{Running time}

Our algorithm uses mergesort to sort the array and count the number of significant inversions at the same time, so the running time of our algorithm will be $O(n\log n)$

\subsection*{Local minimum}

\subsubsection*{Problem Model}

In this problem, we are give a complete binary tree $T$. Each node $v$ of $T$ is labeled with a real number $x_v$. For each node in the tree, we can only determine its value $x_v$ by probing the node $v$.

Our goal is to find a local minimum, that is if the label $x_v$ is less than the label $x_w$ for all the nodes $w$ that are joined to $v$ by an edge.  We also have to find this local minimum of $T$using only $O(log n)$ probes to the nodes of T.

\subsubsection*{Pseudocode}

\begin{algorithm}[H]
\caption{Local minimum pseudocode}
\begin{algorithmic}[1]
\end{algorithmic}
\end{algorithm}

\subsubsection*{Implementation}

\subsubsection*{Running time}

\end{document}