\documentclass{article}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage{subcaption}
\usepackage[linewidth=1pt]{mdframed}
\usepackage[colorlinks]{hyperref}

\usepackage{verbatim}

\usepackage{algorithm}
\usepackage{algpseudocode}

\hypersetup{citecolor=DeepPink4}
\hypersetup{linkcolor=DarkRed}
\hypersetup{urlcolor=Blue}

\usepackage{cleveref}

\setlength{\parindent}{1em}
\setlength{\parskip}{1em}
\renewcommand{\baselinestretch}{1.0}

\begin{document}

\begin{titlepage}
	\centering
	{\scshape\LARGE Assignment 4\par}
	\vspace{1cm}
	{\scshape\Large Algorithms \& Complexity (CIS 522-01)\par}
	\vspace{1.5cm}
	{\Large\itshape Javier Arechalde\par}
	\vfill
	{\large \today\par}
\end{titlepage}

\section*{Part A: Read the solved exercises and Practice}

\subsection*{Solved excercise \#1 in Chapter 5}

In this problem, we are given an array containing $n$ entries. Inside this array, we haev a peak entry $p$ in a position $j$ of the array, so that the array positions prior to $p$ go in increasing order until we reach $p$, and the values after $p$ go in straight decreasing order.

Our goal is to find that peak entry $p$ without having to read the entire array, and only by reading as few values as possible. 

\subsubsection*{Algorithm Pseudocode}

\begin{algorithm}[H]
\caption{Finding maximum pseudocode}
\begin{algorithmic}[1]
\Function{Findmaximum}{$pos_{start},pos_{end},array$}
 \State $n = (pos_{start}+pos_{end})/(2)$
 \If{$array(\frac{n}{2}-1)<array(\frac{n}{2})<array(\frac{n}{2}+1)$}
  \State We have a \textbf{positive slope}, so we havent reached the maximum yet
  \State \Call{Findmaximum}{$(pos_{start}+pos_{end})/2, pos_{end}, array$}
 \ElsIf{$array(\frac{n}{2}-1)>array(\frac{n}{2})>array(\frac{n}{2}+1)$}
  \State We have a \textbf{negative slope}, we already passed the maximum
  \State \Call{Findmaximum}{$pos_{start},(pos_{start}+pos_{end})/2$}
 \ElsIf{$array(\frac{n}{2}-1)>array(n/2)<array(\frac{n}{2}+1)$}
  \State We have found the \textbf{maximum point}
  \State \Return value(n/2)
 \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection*{Solution for problem instance of size $10$}

Now we are going to prove that our algorithm works, by manually running it over a sample set of size $10$. This will be our problem's sample set:

$$S = [1,2,4,12,14,21,6,4,3,1]$$

When we start running the algorithm, we will first check the number in the $5^{th}$ position.

In this case we will have that $S[4] = 12<S[5] = 14<S[6] = 21$, which means that we are in a positive slope, and we still haven't reached the peak value $p$. Then we will call the function again, so in the next iteration of our algorithm, we will work with the set that is on the right side of the value that we checked.

$$S' = [14,21,6,4,3,1]$$

Now we will check the $3^{rd}$ position. In this case we have that $S[2] = 21>S[3] = 6>S[4] = 4$, which means that we are in a negative slope, so we already passed the peak value $p$. Thus, we will call the function again, and in the next iteration of our algorithm we will work with the set at the left of the value we just checked.

$$S'' = [14,21,6]$$

Now we will check the middle position, in this case the $2^{nd}$ position. We get the result that $S[1] = 14<S[2] = 21>S[3] = 6$, which means that the number we are checking is indeed the peak entry $p$. Now we will return that value, and stop running our algorithm.

$$max = 21$$

\subsubsection*{Time Complexity}

In this problem, with each one of the recursive calls, we reduce the problem to one of at most half the size of the initial problem. Then,

$$T(n)\leq T(n/2) + c$$

when $n>2$, and

$$T(2)\leq c$$

Then, we can confirm that the running time of our algorithm will be $O(\log n)$.

\subsection*{Solved exercise \#2 in Chapter 5}

In this problem, we have an investment company that stores during $n$ consecutive days the values of a given stock. For each of these days, the stock has a price $p(i)$ per share for the stock on that day. We assume that the stock prize was fixed on that day.

The goal is to find, without having to check each possible combination of days, which will take $O(n^2)$, in which day they should have bought the shares, and in which day they must have sold them to make as much money as possible.

\subsubsection*{Algorithm Pseudocode}

\begin{algorithm}[H]
\caption{Stocks Divide-and-Conquer pseudocode}
\begin{algorithmic}[1]
\Function{Max}{list}
 \State $max$
 \For{element in list}
  \If{$element>max \quad \textbf{or} \quad max == NA$}
   \State max = element
  \Else{}
   \State \textbf{continue}
  \EndIf
 \EndFor
 \State \Return max
\EndFunction
\State
\Function{Min}{list}
 \State $min$
 \For{element in list}
  \If{$element<min \quad \textbf{or} \quad min == NA$}
   \State min = element
  \Else{}
   \State \textbf{continue}
  \EndIf
 \EndFor
 \State \Return min
\EndFunction
\State
\Function{FindOpt}{$array$}
\If{$len(array)>2$}
 \State $Larray = array[0:len(array)/2]$
 \State $Rarray = array[len(array)/2:len(array)]$
 \State
 \State LSide = \Call{FindOpt}{$Larray$}
 \State RSide = \Call{FindOpt}{$Rarray$}
 \State
 \State LOpt = LSide[1] - LSide[0]
 \State ROpt = RSide[1] - RSide[0]
 \State MOpt = \Call{Max}{RSide} - \Call{Min}{LSide}
 \State
 \State Marray = [\Call{Min}{LSide},\Call{Max}{RSide}]
 \State
 \State maxvalue = \Call{Max}{LOpt,ROpt,MOpt}

 \If {$maxvalue == LOpt$}
  \State \Return LSide
 \ElsIf{$maxvalue == ROpt$}
  \State \Return RSide
 \ElsIf{$maxvalue == MOpt$}
  \State \Return Marray
 \EndIf
 \State
\ElsIf{$len(array) <= 2$}
 \State \Return array
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection*{Solution for problem instance of size $10$}

Now we are going to prove that our algorithm works, by manually running it over a sample set of size $10$. This will be our problem's sample set:

$$S = [7,4,3,2,5,7,10,20,14,7]$$

First, as the array is longer than 2, we will divide it into two sets recursively until we have arrays of length smaller or equal to 2.

$$[7,4,3,2,5] \quad [7,10,20,14,7]$$

$$[7,4] \quad [3,2,5] \quad [7,10] \quad [20,14,7]$$

$$[7,4] \quad [3,2] \quad [5] \quad [7,10] \quad [20,14] \quad [7]$$

Now we are going to compare set by set, if the optimal solution between one set, compare it with the other set, and compare it also with the maximum of the "right" set and the minimum of the "left" set, and see which one gives us a better solution.

Now we are going to compare the sets, to see which is the best solution, between $S$, $S'$ or $p(j)-p(i)$, over $i \in S$ and $j \in S'$. We will return the best solution in each iteration.

$$[7,4] \quad \& \quad [3,2]$$

$$OptL = 4-7 = -3 \quad OptR = 2-3 = -1 \quad OptM = 3-4 = -1$$

$$[5] \quad \& \quad [7,10]$$

$$OptM = 10-5 = 5 \quad OptR = 3$$

$$[20,14] \quad  \& \quad [7]$$

$$OptL = -6 \quad OptM = 7-14 = -7$$

We return $[3,2] \quad [5,10] \quad [20,14]$.

Now we have:

$$[3,2] \quad [5,10] \quad [20,14]$$

Lets start comparing.

$$[3,2] \quad \& \quad [5,10]$$

$$OptL = -1 \quad OptR = 5 \quad OptM = 10 - 2 = 8$$

We return $[2,10]$.

Now we have:

$$[2,10] \quad \& \quad [20,14]$$

$$OptL = 8 \quad OptR = -6 \quad OptM = 18$$

We finally return $[2,20]$, and that will be our final result.

\subsubsection*{Time Complexity}

As we said, in this problem, we will have to recursively subdivide our array, and take the best possible solution out of this three possible solutions:

\begin{itemize}
 \item The optimal solution on $S$
 \item The optimal solution on $S'$
 \item the optimal solution of $p(j)-p(i)$, over $i \in S$ and $j \in S'$.
\end{itemize}

The first two items are computed, in time $T(n/2)$ by recursion, and the third item is computed by finding the maximum in $S'$ and the minimum in $S$, which can be done in $O(n)$ time. Then our running time $T(n)$ satisfies

$$T(n) \leq 2T(\frac{n}{2})+O(n)$$,

so the time complexity of our implementation will be $O(n\log n)$.


\section*{Part B: Problem Solving}

\subsection*{Significant inversion}

\subsubsection*{Problem Model}

In this problem, we are given a sequence of $n$ numbers $a_1,...,a_n$, which we will we assume that are all distinct, and we define inversion to be a pair $i<j$ such that $a_i>a_j$. We call a pair \textit{significant inversion} if $i<j$ and $a_i<2a_j$.

Our goal is to count the number of \textit{significant inversions} between two orderings, using an algorithm that has $O(n \log n)$ time complexity.

\subsubsection*{Pseudocode}

\begin{algorithm}[H]
\caption{Significant inversion pseudocode}
\begin{algorithmic}[1]
\end{algorithmic}
\end{algorithm}

\subsubsection*{Running time}


\subsection*{Local minimum}

\subsubsection*{Problem Model}

In this problem, we are give a complete binary tree $T$. Each node $v$ of $T$ is labeled with a real number $x_v$. For each node in the tree, we can only determine its value $x_v$ by probing the node $v$.

Our goal is to find a local minimum, that is if the label $x_v$ is less than the label $x_w$ for all the nodes $w$ that are joined to $v$ by an edge.  We also have to find this local minimum of $T$using only $O(log n)$ probes to the nodes of T.

\subsubsection*{Pseudocode}

\begin{algorithm}[H]
\caption{Local minimum pseudocode}
\begin{algorithmic}[1]
\end{algorithmic}
\end{algorithm}

\subsubsection*{Implementation}

\subsubsection*{Running time}

\end{document}