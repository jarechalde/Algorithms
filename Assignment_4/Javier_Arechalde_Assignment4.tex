\documentclass{article}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage{subcaption}
\usepackage[linewidth=1pt]{mdframed}
\usepackage[colorlinks]{hyperref}

\usepackage{verbatim}

\usepackage{algorithm}
\usepackage{algpseudocode}

\hypersetup{citecolor=DeepPink4}
\hypersetup{linkcolor=DarkRed}
\hypersetup{urlcolor=Blue}

\usepackage{cleveref}

\setlength{\parindent}{1em}
\setlength{\parskip}{1em}
\renewcommand{\baselinestretch}{1.0}

\begin{document}

\begin{titlepage}
	\centering
	{\scshape\LARGE Assignment 4\par}
	\vspace{1cm}
	{\scshape\Large Algorithms \& Complexity (CIS 522-01)\par}
	\vspace{1.5cm}
	{\Large\itshape Javier Arechalde\par}
	\vfill
	{\large \today\par}
\end{titlepage}

\section*{Part A: Read the solved exercises and Practice}

\subsection*{Solved excercise \#1 in Chapter 5}

In this problem, we have an array with $n$ entries, and inside this array, we have a peak entry $p$ in a position $j$ of the array, so that the values in the array prior to $j$ go in increasing order, and after the peak value, they go in decreasing order.

Our goal is to find that peak entry $p$ without having to read the entire array, and only by reading as few values as possible. 

\subsubsection*{Algorithm Pseudocode}

\begin{algorithm}[H]
\caption{Finding maximum pseudocode}
\begin{algorithmic}[1]
\Function{Findmaximum}{$pos_{start},pos_{end},array$}
 \State $n = \frac{pos_{start}+pos_{end}}{2}$
 \If{$array(\frac{n}{2}-1)<array(\frac{n}{2})<array(\frac{n}{2}+1)$}
  \State We have a \textbf{positive slope}, so we havent reached the maximum yet
  \State \Call{Findmaximum}{$(pos_{start}+pos_{end})/2, pos_{end}, array$}
 \ElsIf{$array(\frac{n}{2}-1)>array(\frac{n}{2})>array(\frac{n}{2}+1)$}
  \State We have a \textbf{negative slope}, we already passed the maximum
  \State \Call{Findmaximum}{$pos_{start},(pos_{start}+pos_{end})/2$}
 \ElsIf{$array(\frac{n}{2}-1)>array(n/2)<array(\frac{n}{2}+1)$}
  \State We have found the \textbf{maximum point}
  \State \Return value(n/2)
 \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection*{Solution for problem instance of size $10$}

In this case, we will run our algorithm, when we have an instance of size $10$.

In this problem's scope, we will have an set of increasing numbers that grow until a maximum, followed by another set of numbers that go in decreasing order.

This will be our problem's working set:

$$S = [1,2,4,12,14,21,6,4,3,1]$$

If we start running the algorithm, we will check the number in the $5^{th}$ position.

In this case we will have that $S[4]<S[5]<S[6]$, which means that we are in a positive slope, and we still haven't reached the maximum. Then we will call the function again, so in the next iteration of our algorithm, we will work with this set.

$$S' = [14,21,6,4,3,1]$$

Now we will check the $3^{rd}$ position. In this case we have that $S[2]>S[3]>S[4]$, which means that we are in a negative slope, so we already passed the maximum. Thus, we will call the function again, and in the next iteration of our algorithm we will work with this set.

$$S'' = [14,21,6]$$

Now we will check the middle position, in this case the $2^{nd}$ position. We get the result that $S[1]<S[2]>S[3]$, which means that the number we are checking is indeed the maximum. Now we will return that value, and stop running our algorithm.

$$max = 21$$

\subsubsection*{Time Complexity}

In this problem, with each one of the calls, we reduce the problem to one of at most half the size of the initial problem. Then:

$$T(n)\leq T(n/2) + c$$

when $n>2$, and

$$T(2)\leq c.$$

Then, we can prove this by unrolling, and the running time of our algorithm will be $\log n$.

\subsection*{Solved exercise \#2 in Chapter 5}

In this problem, we have an investment company that looks at $n$ consecutive days of a given stock. For each of these days, the stock has a price $p(i)$ per share for the stock on that day. We assume that the stock prize was fixed on that day.

The goal is to find, without having to check each possible combination of days, which will take $O(n^2)$, in which day they should have bought the shares, and in which day they must have solved them to make as much money as possible.

\subsubsection*{Algorithm Pseudocode}

\begin{algorithm}[H]
\caption{Stocks Divide-and-Conquer pseudocode}
\begin{algorithmic}[1]
\Function{FindOpt}{Set}
 \If{length(Set)>2}
 \EndIf
 \Else{}
 \EndIf
\EndFunction


\For{$i \in S$}
 \If{$S[i]<min$}
  \State $min = S[i]$
 \EndIf
 \Else{}
  \State Continue
 \EndIf
\EndFor
\For{$j \in S'$}
 \If{$S'[j]>max$}
  \State $max = S'[j]$
 \EndIf
 \Else{}
  \State Continue
 \EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

\subsubsection*{Solution for problem instance of size $10$}

\subsubsection*{Time Complexity}

\section*{Part B: Problem Solving}

\subsection*{Significant inversion}

\subsubsection*{Problem Model}

In this problem, we are given a sequence of $n$ numbers $a_1,...,a_n$, which we will we assume that are all distinct, and we define inversion to be a pair $i<j$ such that $a_i>a_j$. We call a pair \textit{significant inversion} if $i<j$ and $a_i<2a_j$.

Our goal is to count the number of \textit{significant inversions} between two orderings, using an algorithm that has $O(n \log n)$ time complexity.

\subsubsection*{Pseudocode}

\begin{algorithm}[H]
\caption{Significant inversion pseudocode}
\begin{algorithmic}[1]
\end{algorithmic}
\end{algorithm}

\subsubsection*{Running time}


\subsection*{Local minimum}

\subsubsection*{Problem Model}

In this problem, we are give a complete binary tree $T$. Each node $v$ of $T$ is labeled with a real number $x_v$. For each node in the tree, we can only determine its value $x_v$ by probing the node $v$.

Our goal is to find a local minimum, that is if the label $x_v$ is less than the label $x_w$ for all the nodes $w$ that are joined to $v$ by an edge.  We also have to find this local minimum of $T$using only $O(log n)$ probes to the nodes of T.

\subsubsection*{Pseudocode}

\begin{algorithm}[H]
\caption{Local minimum pseudocode}
\begin{algorithmic}[1]
\end{algorithmic}
\end{algorithm}

\subsubsection*{Implementation}

\subsubsection*{Running time}

\end{document}